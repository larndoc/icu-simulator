#plot power spectral density of the sawtooth waveform? 
#plot frequency sprectrum of the sawtooth waveform? 

import serial 
import argparse
import string
import time 
import datetime
import binascii
import logging
import numpy
import statistics
from threading import Thread
import math
import os

def build_config_command_val(fee_number): 
	print(fee_number)
	cmd = input('> please choose an input: ')	
	cmd_val = (int(cmd, 0)).to_bytes(1, byteorder = 'big')
	read_write = (
	"0) read \n" 
	"1) write \n"
	)
	print(read_write)
	rm_wr = input('> please choose an input: ')
	rm_wr_val = (int(rm_wr, 0)).to_bytes(1, byteorder = 'big')
	config_id = input('>please enter config id: ')		
	config_id_val = (int(config_id, 0)).to_bytes(1, byteorder = 'big')
	config_val = input('>please enter config val: ')
	temp = int(config_val, 0)
	choice = (temp).to_bytes(3, byteorder='big')
	return cmd_val + rm_wr_val + config_id_val + choice
	
def build_fee_packet(fee_number): 						
	print(fee_number)
	fee_interface = input('please choose an input: ')
	return  (int(fee_interface, 0)).to_bytes(1, byteorder = 'big')
	

def debug_information(data): 
	print(binascii.hexlify(data))
	
def minute_tick(current_minutes, old_minutes): 
	if(current_minute != old_minutes): 
		old_minutes  = current_minute
		return True 
	else: 
		return False		
						

	

		 
class fee_packet(Thread):
	files = dict()
	labels = dict()
	values = dict()
	file_handle = ''
	logdir = ''
	status = '' 

	def __init__(self, serial_port, logdir):
		super(fee_packet, self).__init__()
		self.begin_receiving = True; 
		self.port          = serial_port 
		self.logdir 		 = logdir 
		self.fee_science_reciever = fee_science_reciever(self) 
		
	def update_global_time(self): 
		self.current_time = datetime.datetime.now()
		
	def create_files(self):
		self.update_global_time()
		t_str = self.current_time.strftime("%Y%m%d_%H%M%S")
		for key in self.files: 
			self.file_handle = open(self.files[key] + t_str + '.csv', 'a')
			self.file_handle.write(",".join(self.labels[key]))
		
		
		
	def run(self): 
		self.house_keeping = hk_data(self)
		while(self.begin_receiving == True):
			if self.port.in_waiting > 0 : 
				self.header_data 					= bytearray((self.port).read(size = 5))
				clock_frequency						= 128
				self.status						= str(self.header_data[0])
				self.sync_counter       				= ("{}".format(int.from_bytes(self.header_data[1 : 5], byteorder = 'big')));  
				delta_val 						= float(self.sync_counter) * 1/clock_frequency
				self.time 						= self.current_time + datetime.timedelta(milliseconds = delta_val*1000)
				#the constructor takes care of creating the relevant files and labels for house keeping and call to update function in house-keeping
				#hk_data hkpkt(self) 
				#the constructor takes care of creating the relevant files and labels for science and call to update function in science
				self.house_keeping.update()
				self.fee_science_reciever.update()
			#before reading any data flush any input that exists in the buffer
				for key, value in self.values.items(): 
					self.files[key].write(value)
class hk_data(fee_packet): 	
		def __int__(self,fee_packet):
			self.logdir = logdir
			fee_packet.files['fib'] = 'FIB_HK_TM'
			fee_packet.files['fob'] = 'FOB_HK_TM'
			fee_packet.files['fsc'] = 'FSC_HK_TM' 
			fee_packet.labels['fib'] = ["time", "status", "x", "y", "z"]
			fee_packet.labels['fob'] = ["time", "status", "x", "y", "z"]
			fee_packet.labels['fsc'] = ["time", "status", "x", "y", "z"]
			fee_packet.create_files(self.hk_files, self.hk_sci_labels)
			self.update(fee_packet); 
		def update(self):  
			if(fee_packet.status == '0'):
				pcu_data = ((fee_packet.port).read(size = 32))
				fib_hk_data = ((fee_packet.port).read(size = 40))
				fob_hk_data = ((fee_packet.port).read(size = 4))
				fsc_hk_data = ((fee_packet.port).read(size = 51))
				for i in range(0, 4): 
					values["fob"].append(str(fob_hk_data[i]))
				
				for i in range(0, 51): 
					values["fsc"].append(str(fsc_hk_data[i])) 
				
				for i in range(0, 40): 
					values["fib"].append(str(fib_hk_data[i]))
				
				for i in range(0, 31): 
					values["pcu"].append("{}".format(int.from_bytes(fsc_sci_data[8:11], byteorder = 'big', signed = False)))
				
				fee_packet.values = values; 
					






class fee_science_reciever(fee_packet): 
	#initialization of the baud rate 
	#initialization of the argument parser for the user to enter the desired communication port 
	#initialization of the science data and the x, y and z components from all 3 interfaces 
	#setting up the communication via the usb interface with a timeout of 0.5 seconds 
	#the print function messes with the data that is being printed on the console 
	#s = serial.Serial('COM4', 115200, timeout = 1)
	def __init__(self, fee_packet): 
		fee_packet.files['fib'] = 'FIB_SCI_TM'
		fee_packet.files['fob'] = 'FOB_SCI_TM' 
		fee_packet.files['fsc'] = 'FSC_SCI_TM'
		fee_packet.labels['fib'] = ["time", "status", "x", "y", "z"]
		fee_packet.labels['fob'] = ["time", "status", "x", "y", "z"]
		fee_packet.labels['fsc'] = ["time", "status", "sensor temperature controller", "laser temperature controller","laser current controller","microwave reference controller" , "zeeman_controller" ,  "science_data_id" ,  "science_data" , "time_stamp"]
		fee_packet.create_files()

	def update(self):	
		if fee_packet.status == '1': 
			header  = bytearray((self.port).read(size = 3))
			n = dict(fib = 0, fob = 0, fsc = 0)
			parsed = dict(fib = "", fob = "", fsc = "")
			n["fib"].append(header[0])
			n["fob"].append(header[1])
			n["fsc"].append(header[2])
			for key in parsed: 
				for n in n[key]: 
					values = self.parse_fee(key)
					parsed[key].append("{:s}, {:s}\n".format(t.strftime("%Y%m%dT%H:%M:%S.%f"),",".join(str(values))))
				return parsed 
				
	def parse_fee(self, fee, values):
		values = []
		if(fee == 'fsc'):
			for i in range(0, self.n_fsc):
				fsc_sci_data  = self.port.read(size = 10);
				values[fee].append(fsc_sci_data[0])
				values[fee].append(fsc_sci_data[1])
				values[fee].append(fsc_sci_data[2])
				values[fee].append(fsc_sci_data[3])
				values[fee].append("{}".format(int.from_bytes(fsc_sci_data[4:8], byteorder = 'big', signed = False)))
				values[fee].append("{}".format(int.from_bytes(fsc_sci_data[8:11], byteorder = 'big', signed = False)))
				self.zeeman_controller.append(zeeman_controller)
				self.mc_controller.append(microwave_reference_controller)
			
		if(fee == 'fob'):
			for i in range(0,self.n_fob) :
				fob_sci_data = self.port.read(size = 10)
			for i in range(0, 3):
				values.append((int.from_bytes(fob_sci_data[1][3*i + 2 : 3*i - 1], byteorder = 'big', signed = True)))
			values[fee].append(fob_sci_data[9])
	
		if(fee == 'fsc'):
			for i in range(0, self.n_fib): 
				fib_sci_data = self.port.read(size = 10)
			for i in range(0, 3): 
				values[fee].append(int.from_bytes(fib_sci_data[3*i : 3*i + 3], byteorder = 'big', signed = True))
		fee_packet.values = values
	
		
		
if __name__ == '__main__':
		baud_rate = 115200
		parser = argparse.ArgumentParser();
		parser.add_argument(dest = 'port', help = "display the interface port to the computer ", type = str)
		parser.add_argument('--abs_path', dest = 'abs_path', help = "check for absolute directory", type = str)
		args 	 = parser.parse_args()
		sci_port = serial.Serial(args.port, baud_rate, timeout = 0.5)
		logging.basicConfig(filename='debugger.log', format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
		logger = logging.getLogger()
		logger.setLevel(logging.INFO) 
		science_handler = fee_packet(sci_port, parser.parse_args().abs_path)
		science_handler.start()
		switch_off = False; 
		science_handler.current_time = datetime.datetime.now()
		science_handler.time = science_handler.current_time
		while not science_handler.is_alive(): 
			pass 
		time.sleep(2)
		
		## needed as arduino needs to come up, do not remove. 
		cmd_menu 	= (	"1) Set Time Command \n"
						"2) Set Config Command \n"
						"3) Science Mode \n"
						"4) Config Mode \n"
						"5) Power on fee \n"
						"6) Power off fee \n"
						"7) End the script \n")
		fee_number 	= (	"0> FIB \n"
						"1> FOB \n"
						"2> FSC \n")
		command = ''
		
	
		#continue to stay in the loop until the user wants to exit the script in which case we must end the thread
		while(switch_off == False):  
			print(cmd_menu)
			nb = input('please choose an option: ')
			try: 
				choice = int(nb)
			except ValueError as error_msg: 
				print('unable to parse choice as an integer %s' % error_msg)
				logging.debug(error_msg)
				continue 
			if(nb == '2'): 
				command = ((int(nb, 16)).to_bytes(1, byteorder = 'big') + build_config_command_val(fee_number));
			elif(nb == '4'):
				command = ((int(nb, 16).to_bytes(1, byteorder = 'big'))); 
			elif(nb == '3'):
				command = ((int(nb, 16)).to_bytes(1, byteorder = 'big'))
			elif(nb == '5' or nb == '6'): 
				command = ((int(nb, 16)).to_bytes(1, byteorder = 'big')) + build_fee_packet(fee_number) 
			elif(nb == '7'): 
				science_handler.begin_recieving = False
				switch_off = True
			if(nb != '7' and science_handler.is_alive() == True):
					science_handler.port.write(bytes(command));
			print(command)	
		science_handler.join()
		print("program end")


